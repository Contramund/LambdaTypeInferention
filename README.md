# Тайпчекер для просто типизированного лямбда-исчисления
## Установка и тестирование
Для того чтобы запустить этот проект, Вам потребуются установленные компилятор `ghc` и сборщик `Cabal`.

- Чтобы установить зависимости запустите

```
cabal update
cabal build --only-dependencies --enable-tests --enable-benchmarks
```

- Чтобы собрать проект запустите

```
cabal build --enable-tests --enable-benchmarks all
```

- Для запуски встроенных тестов запустите

```
cabal test all
```
Или еще лучше (новая версия)
```
cabal v2-test
```
- Для ручной проверки можно воспользоваться консолью `ghci` через

```
ghci src/TypeChecker.hs
```

## Система типов
Для удобства понимания и самостоятельного написания тестов краткая инструкция по синтаксису :

### Типы
Строятся классически индуктивно :
- Если `s` — это строка, то `TVar s` — это тип (с именем `s`)
- Если `T1` и `T2` — это типы, то `T1 :-> T2` — это тип (стрелочный)
Как и положено, стрелка право-ассоциативная. Общий тип "Типов" обозначается через `Type`.

### Термы
Строятся классически индуктивно :
- Если `s` — это строка, то `Var s` — это терм (с именем `s`)
- Если `E1` и `E2` — это термы, то `E1 :@ E2`(применение) — это терм
- Если `E` — это терм, `T` — тип, a `s` — строка, то `Lam s T E`(абстракция по `s` типа `T`) — это терм
Как и положено, оператор применения `:@` лево-ассоциативный. Общий тип "Термов" обозначается через `Expr`(Expresion)

### Контекст
Представляет из себя упрощенный словарь, а именно массив пар (кортежей) из строки-названия термовой переменной и соответствующего типа. 

Для удобства и читаемости кода для строк заведен тип-синоним `Symb`.

## Основные функции
Весь алгоритм по сути состоит из двух частей : вычисление типа по терму с контекстом и сравнение типа с тем, который мы проверяем. Так как при типизации по Чёрчу у нас для типизуемости все типы всех переменных должны быть заранее заданы, то вычислить реальный тип оказалось не так сложно.

### check :: Env -> Expr -> Type -> Bool
Самая главная функция проверки это `check`. Она принимает терм, предворенный его контекстом, а потом предполагаемый тип. По этим данным она возвращает булево значение, соответственно "такой" (`True`) по Чёрчу у терма с заданным контекстом тип или "не такой" (`False`).

### inferType :: MonadError String m => Env -> Expr -> m Type
Функция, которая на самом деле выполняет всю работу это `inferType`, которая по контексту с термом выдает нам тип. Для удобства реальной работы с функцией, возвращаемое значение реализует `MonadFail String m`, то есть, если все хорошо посчиталось, то мы получаем нужный результат, а иначе информативное (насколько это возможно понять изнутри функции) сообщение о том, что помешало типизировать.

На самом деле можно было обойтись и просто `Monad`, но исторически сложилось, что был использован именно `MonadFail` и отлавливать ошибку в `check` впринципе разницы вроде бы нет от чего.

## Тесты
Тесты для функций `inferType` и `check` находятся в папке `test/` под названиями `inferTypeTest.hs` и `checkTest.hs` соответственно. Как и говорилось в ветке `main`, тесты исполняются с помощью библиотеки `HUnit`. 
